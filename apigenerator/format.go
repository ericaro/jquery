package apigenerator

import (
	"fmt"
	"io"
	"log"
	"text/template"
)

const (
	Boilerplate = `package jquery
//this file is generated by jquery/gen : Do not edit use go generate instead

import "github.com/gopherjs/gopherjs/js"

var (
	JQ = js.Global.Get("jQuery")
	BrowserVersion = js.Global.Get("jQuery.browser.version")
	FxInterval = js.Global.Get("jQuery.fx.interval")
	FxOff = js.Global.Get("jQuery.fx.off")
	)

	`
)

var (
	EntryTemplate = template.Must(template.New("Entry").
		Funcs(funcs).
		Parse(EntryTmpl))
)

func Format(w io.Writer, entries ...*Entry) {
	w.Write([]byte(Boilerplate))

	// merge identical entries
	mentries := make(map[string]*Entry)

	for _, e := range entries {
		if target, exists := mentries[e.RawName]; exists {
			//need a merge
			MergeEntries(e, target)
		} else {
			mentries[e.RawName] = e
		}
	}

	jtypes := make(map[string]*JType)

	for _, e := range mentries {
		//lazy get the jtype associated
		receiver := e.Receiver()
		jtype, exists := jtypes[receiver]
		if !exists {
			jtype = NewJType(receiver)
			jtypes[receiver] = jtype
		}
		switch e.Type {
		case "method":
			jtype.Methods[e.Name()] = e
		case "property":
			jtype.Properties[e.Name()] = e
			// default:
			// 	log.Printf("Unknown type %v", e.Type)
		}
	}

	//hacking some exception:
	//type callbacks and defered have the same name as there constructor: change that
	// in a more "goesque" way NewCallback, and NewDeferred

	jtypes[""].Methods["Callbacks"].RawName = "NewCallbacks"
	jtypes[""].Methods["Deferred"].RawName = "NewDeferred"

	// move fn methods to jQuery but prefixed with Fn
	fn := jtypes["JQuery.fn"]
	delete(jtypes, "JQuery.fn")
	for _, m := range fn.Methods {
		was := m.RawName
		m.RawName = "jQuery.Fn" + Title(m.Name())
		log.Printf("Moving %v to %v", was, m.RawName)
		jtypes[""].Methods[m.Name()] = m
	}

	// generate jquery static
	for _, e := range jtypes[""].Methods {
		EntryTemplate.ExecuteTemplate(w, "JQueryStatic", e)
	}

	//supported is a map (to be filled) with currently supported JType
	supported := map[string]bool{
		"JQuery":         true,
		"Event":          true,
		"Callbacks":      true,
		"Deferred":       true,
		"":               false, // handle by so called static template
		"JQuery.browser": false, // handle by hand in the boiler plate
		"JQuery.fx":      false, // handle by hand in the boiler plate
	}
	//fill only supported
	for k, e := range jtypes {
		generate, exists := supported[k]
		switch {

		case generate:
			log.Printf("Generating type %v", k)
			EntryTemplate.ExecuteTemplate(w, "JType", e)

		case !exists:
			log.Printf("Not yet supported %v", k)
			for _, m := range e.Properties {
				log.Printf("    property %v %v", m.Name(), m.Return)
			}
			for _, m := range e.Methods {
				log.Printf("    method %v", m.Name())
			}
		}
	}

}

//Merge data from src into target
func MergeEntries(src, target *Entry) {
	target.Desc = fmt.Sprintf("%s OR %s", target.Desc, src.Desc)
}
